# Bitnami PostgreSQL Helm Chart Configuration
# Chart: https://github.com/bitnami/charts/tree/main/bitnami/postgresql
# Version: 16.x

# These values override the Bitnami PostgreSQL defaults
# Reference: https://artifacthub.io/packages/helm/bitnami/postgresql

# Architecture: replication for HA, standalone for dev/staging
architecture: replication
replicaCount: 2  # 1 primary + 1 read replica (can scale to more)

# Global settings
global:
  postgresql:
    auth:
      enablePostgresUser: true
      postgresPassword: ""  # From External Secrets
      username: monobase
      password: ""  # From External Secrets
      database: monobase
      existingSecret: postgresql-credentials
      secretKeys:
        adminPasswordKey: postgres-password
        userPasswordKey: password
        replicationPasswordKey: replication-password

# Primary configuration
primary:
  # Persistence
  persistence:
    enabled: true
    storageClass: ""  # Uses global.storage.className (resolved by parent chart)
    size: 100Gi
    accessModes:
      - ReadWriteOnce

  # Resource limits
  resources:
    requests:
      cpu: 1
      memory: 2Gi
    limits:
      cpu: 2
      memory: 4Gi

  # Pod Disruption Budget
  podDisruptionBudget:
    create: true
    minAvailable: 1

  # Security Context
  podSecurityContext:
    enabled: true
    fsGroup: 1001

  containerSecurityContext:
    enabled: true
    runAsUser: 1001
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL

  # Affinity - spread across nodes
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchLabels:
                app.kubernetes.io/name: postgresql
                app.kubernetes.io/component: primary
            topologyKey: kubernetes.io/hostname

# Read replicas configuration
readReplicas:
  replicaCount: 1

  # Persistence
  persistence:
    enabled: true
    storageClass: ""
    size: 100Gi
    accessModes:
      - ReadWriteOnce

  # Resource limits (can be lower than primary)
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 1
      memory: 2Gi

  # Security Context
  podSecurityContext:
    enabled: true
    fsGroup: 1001

  containerSecurityContext:
    enabled: true
    runAsUser: 1001
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL

  # Affinity
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchLabels:
                app.kubernetes.io/name: postgresql
            topologyKey: kubernetes.io/hostname

# TLS/SSL configuration
tls:
  enabled: true
  # Certificates from cert-manager or External Secrets
  certificatesSecret: postgresql-tls
  certFilename: tls.crt
  certKeyFilename: tls.key
  certCAFilename: ca.crt

# Monitoring
metrics:
  enabled: true
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 200m
      memory: 256Mi

  # ServiceMonitor for Prometheus
  serviceMonitor:
    enabled: false  # Enable when monitoring is enabled
    interval: 30s

# Network Policy
networkPolicy:
  enabled: true
  allowExternal: false
  # Only allow traffic from API service
  ingressRules:
    primaryAccessOnlyFrom:
      enabled: true
      namespaceSelector: {}
      podSelector:
        matchLabels:
          app.kubernetes.io/name: api
    readReplicasAccessOnlyFrom:
      enabled: true
      namespaceSelector: {}
      podSelector:
        matchLabels:
          app.kubernetes.io/name: api

# PostgreSQL configuration
# See: https://www.postgresql.org/docs/16/runtime-config.html
postgresql:
  # Shared buffers (25% of RAM is recommended)
  sharedBuffers: 512MB

  # Work memory (for sorting/hashing)
  workMem: 16MB

  # Maintenance work memory (for VACUUM, CREATE INDEX)
  maintenanceWorkMem: 256MB

  # Effective cache size (50-75% of total RAM)
  effectiveCacheSize: 2GB

  # Max connections
  maxConnections: 200

  # Write-ahead log
  walLevel: replica
  maxWalSize: 2GB
  minWalSize: 1GB

  # Checkpoint
  checkpointCompletionTarget: 0.9

  # Logging
  logStatement: ddl  # Log DDL statements (CREATE, ALTER, DROP)
  logMinDurationStatement: 1000  # Log queries slower than 1s
  logLinePrefix: '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

  # Replication
  maxWalSenders: 10
  walKeepSize: 1GB
  hotStandby: on

# Backup configuration
# Note: Use Velero for Kubernetes-native backups (recommended)
# See: infrastructure/velero/backup-schedules/
#
# For application-level backups:
backup:
  enabled: false  # Can enable pg_dump backups via cronjobs
  cronjob:
    schedule: "0 2 * * *"  # Daily at 2 AM
    storage:
      existingClaim: ""  # Or use S3 via pg_dump scripts

# pg_hba.conf entries (host-based authentication)
# Default: require SSL, allow from pods in same namespace
pgHbaConfiguration: |-
  # TYPE  DATABASE        USER            ADDRESS                 METHOD
  hostssl all             all             all                     scram-sha-256
  host    replication     replicator      all                     scram-sha-256

# Audit logging (for compliance)
# Use pgaudit extension for detailed audit logging
audit:
  logConnections: true
  logDisconnections: true
  clientMinMessages: error

# Extensions to enable
# monobase API uses: uuid-ossp for UUIDs
postgresqlExtendedConf:
  shared_preload_libraries: 'pg_stat_statements'

# Init scripts (create extensions, etc.)
initdbScripts:
  init.sql: |
    -- Create extensions
    CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    CREATE EXTENSION IF NOT EXISTS "pg_stat_statements";

    -- Create monobase database if not exists (handled by auth.database)
    -- Set default permissions
    GRANT ALL PRIVILEGES ON DATABASE monobase TO monobase;

# Volume permissions (for security contexts)
volumePermissions:
  enabled: true
  securityContext:
    runAsUser: 0

# Service configuration
service:
  type: ClusterIP
  ports:
    postgresql: 5432

# Update strategy
updateStrategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 0
