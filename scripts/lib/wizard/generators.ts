// Terraform tfvars File Generators

import type { AwsConfig, DoConfig, GcpConfig, K3dConfig } from './collectors';

/**
 * Generate AWS EKS terraform.tfvars content
 */
export function generateAwsTfvars(config: AwsConfig): string {
  return `# AWS EKS Cluster Configuration
# Generated by monobase-infra provision wizard

cluster_name       = "${config.clusterName}"
region             = "${config.region}"
deployment_profile = "${config.deploymentProfile}"
kubernetes_version = "1.31"

# Network configuration
vpc_cidr           = "10.0.0.0/16"
availability_zones = [] # Auto-detect from region

# API endpoint access
enable_public_endpoint = true
api_access_cidrs       = ["0.0.0.0/0"] # ⚠️ CHANGE IN PRODUCTION

# Cluster addons
enable_ebs_csi_driver     = true
enable_cluster_autoscaler = true
enable_irsa               = true  # IAM Roles for Service Accounts
enable_flow_logs          = true

# Optional: Velero backup configuration
# velero_backup_bucket = "my-velero-backups"

# Optional: Route53 zones for ExternalDNS
# route53_zone_arns = ["arn:aws:route53:::hostedzone/ZXXXXXXXXXXXXX"]

tags = {
  environment = "production"
  managed-by  = "terraform"
  project     = "monobase-infra"
}
`;
}

/**
 * Generate DigitalOcean DOKS terraform.tfvars content
 */
export function generateDoTfvars(config: DoConfig): string {
  return `# DigitalOcean DOKS Cluster Configuration
# Generated by monobase-infra provision wizard

cluster_name       = "${config.clusterName}"
region             = "${config.region}"
deployment_profile = "${config.deploymentProfile}"
kubernetes_version = "1.28.2-do.0"

# High availability control plane
ha_control_plane = ${config.haControlPlane}

# Cluster management
auto_upgrade = true
surge_upgrade = true

# Maintenance window (UTC)
maintenance_window_day  = "sunday"
maintenance_window_hour = "04:00"

# Network configuration
vpc_cidr = "10.244.0.0/16"

# Resource tags
tags = ["production", "monobase"]
`;
}

/**
 * Generate GCP GKE terraform.tfvars content
 */
export function generateGcpTfvars(config: GcpConfig): string {
  return `# GCP GKE Cluster Configuration
# Generated by monobase-infra provision wizard

cluster_name       = "${config.clusterName}"
project_id         = "${config.projectId}"
region             = "${config.region}"
kubernetes_version = "1.31"

# Network configuration
network_cidr = "10.0.0.0/16"

# Node pool configuration
# Sized for multi-tenant SaaS platform
node_pools = {
  general = {
    machine_type = "n2-standard-8"  # 8 vCPU, 32GB RAM per node
    node_count   = 1                # Initial node count
    min_count    = 1                # Minimum for cost control
    max_count    = 2                # Maximum (limited by quota)
    disk_size_gb = 50               # Boot disk size (fits within quota)
  }
}

# Workload Identity (recommended for secure service account access)
enable_workload_identity = true

# Resource labels
tags = {
  environment = "production"
  managed-by  = "terraform"
  project     = "monobase-infra"
}

# Cost Estimates (${config.region}):
# - Control plane (regional): ~$73/month
# - 1x n2-standard-8 node: ~$291/month
# - Storage (50GB PD-SSD): ~$8.50/month
# Total: ~$372.50/month
#
# Scaling (auto-scale 1-2 nodes):
# - 2 nodes: ~$655/month
`;
}

/**
 * Generate GCP GKE main.tf content
 */
export function generateGcpMainTf(): string {
  return `# GCP GKE Cluster Configuration
# Auto-generated by monobase-infra provision wizard

terraform {
  required_version = ">= 1.6"

  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
}

module "gke_cluster" {
  source = "../terraform/modules/gcp-gke"

  cluster_name       = var.cluster_name
  project_id         = var.project_id
  region             = var.region
  kubernetes_version = var.kubernetes_version

  network_cidr = var.network_cidr
  node_pools   = var.node_pools

  enable_workload_identity = var.enable_workload_identity

  tags = var.tags
}
`;
}

/**
 * Generate GCP GKE variables.tf content
 */
export function generateGcpVariablesTf(): string {
  return `# GCP GKE Cluster - Variable Definitions
# Auto-generated by monobase-infra provision wizard

variable "cluster_name" {
  description = "Name of the GKE cluster"
  type        = string
}

variable "project_id" {
  description = "GCP project ID"
  type        = string
}

variable "region" {
  description = "GCP region for the cluster (regional cluster spans multiple zones)"
  type        = string
  default     = "us-central1"
}

variable "kubernetes_version" {
  description = "Kubernetes version for the GKE cluster"
  type        = string
  default     = "1.28"
}

variable "network_cidr" {
  description = "CIDR range for the VPC network"
  type        = string
  default     = "10.0.0.0/16"
}

variable "node_pools" {
  description = "Node pool configurations"
  type = map(object({
    machine_type = string
    node_count   = number
    min_count    = number
    max_count    = number
    disk_size_gb = optional(number, 100)
  }))
  default = {
    general = {
      machine_type = "n2-standard-8"
      node_count   = 1
      min_count    = 1
      max_count    = 3
      disk_size_gb = 100
    }
  }
}

variable "enable_workload_identity" {
  description = "Enable Workload Identity for secure service account access"
  type        = bool
  default     = true
}

variable "tags" {
  description = "Labels to apply to all resources"
  type        = map(string)
  default     = {}
}
`;
}

/**
 * Generate GCP GKE outputs.tf content
 */
export function generateGcpOutputsTf(): string {
  return `# GCP GKE Cluster - Outputs
# Auto-generated by monobase-infra provision wizard

output "cluster_name" {
  description = "GKE cluster name"
  value       = module.gke_cluster.cluster_name
}

output "cluster_id" {
  description = "GKE cluster ID"
  value       = module.gke_cluster.cluster_id
}

output "cluster_endpoint" {
  description = "GKE cluster endpoint"
  value       = module.gke_cluster.cluster_endpoint
}

output "cluster_ca_certificate" {
  description = "GKE cluster CA certificate"
  value       = module.gke_cluster.cluster_ca_certificate
  sensitive   = true
}

output "configure_kubectl" {
  description = "Command to configure kubectl for this cluster"
  value       = module.gke_cluster.configure_kubectl
}

output "external_secrets_sa_email" {
  description = "External Secrets Operator service account email"
  value       = module.gke_cluster.external_secrets_sa_email
}

output "velero_sa_email" {
  description = "Velero backup service account email"
  value       = module.gke_cluster.velero_sa_email
}

output "cert_manager_sa_email" {
  description = "cert-manager service account email"
  value       = module.gke_cluster.cert_manager_sa_email
}
`;
}

/**
 * Generate AWS EKS main.tf content
 */
export function generateAwsMainTf(): string {
  return `# AWS EKS Cluster Configuration
# Auto-generated by monobase-infra provision wizard

terraform {
  required_version = ">= 1.6"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.region
  # Credentials from environment: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY
  # Or AWS profile: AWS_PROFILE=your-profile
}

module "eks_cluster" {
  source = "../terraform/modules/aws-eks"

  cluster_name       = var.cluster_name
  region             = var.region
  kubernetes_version = var.kubernetes_version

  # Network configuration
  vpc_cidr           = var.vpc_cidr
  availability_zones = var.availability_zones

  # API access
  enable_public_endpoint = var.enable_public_endpoint
  api_access_cidrs       = var.api_access_cidrs

  # Deployment size (small/medium/large or custom)
  deployment_profile = var.deployment_profile
  node_groups        = var.node_groups

  # Addons
  enable_ebs_csi_driver     = var.enable_ebs_csi_driver
  enable_cluster_autoscaler = var.enable_cluster_autoscaler
  enable_irsa               = var.enable_irsa
  enable_flow_logs          = var.enable_flow_logs

  # IAM policy scoping (optional but recommended)
  velero_backup_bucket = var.velero_backup_bucket
  route53_zone_arns    = var.route53_zone_arns

  tags = var.tags
}
`;
}

/**
 * Generate AWS EKS variables.tf content
 */
export function generateAwsVariablesTf(): string {
  return `# AWS EKS Cluster - Variable Declarations
# Auto-generated by monobase-infra provision wizard

variable "cluster_name" {
  description = "Name of the EKS cluster"
  type        = string
}

variable "region" {
  description = "AWS region (e.g., us-east-1, us-west-2, eu-west-1)"
  type        = string
}

variable "kubernetes_version" {
  description = "Kubernetes version"
  type        = string
  default     = "1.28"
}

variable "vpc_cidr" {
  description = "CIDR block for VPC"
  type        = string
  default     = "10.0.0.0/16"
}

variable "availability_zones" {
  description = "List of availability zones (leave empty for auto-detection)"
  type        = list(string)
  default     = []
}

variable "enable_public_endpoint" {
  description = "Enable public API endpoint"
  type        = bool
  default     = true
}

variable "api_access_cidrs" {
  description = "CIDR blocks allowed to access EKS API"
  type        = list(string)
  default     = ["0.0.0.0/0"] # CHANGE IN PRODUCTION
}

variable "deployment_profile" {
  description = "Deployment size: small (1-5 clients), medium (5-15), large (15+)"
  type        = string
  default     = "small"
}

variable "node_groups" {
  description = "Custom node group config (leave empty to use deployment_profile)"
  type = map(object({
    instance_types = list(string)
    desired_size   = number
    max_size       = number
    min_size       = number
    disk_size      = optional(number, 100)
    labels         = optional(map(string), {})
    taints = optional(list(object({
      key    = string
      value  = string
      effect = string
    })), [])
  }))
  default = {}
}

variable "enable_ebs_csi_driver" {
  description = "Enable EBS CSI driver (required for storage)"
  type        = bool
  default     = true
}

variable "enable_cluster_autoscaler" {
  description = "Enable cluster autoscaler"
  type        = bool
  default     = true
}

variable "enable_irsa" {
  description = "Enable IAM Roles for Service Accounts"
  type        = bool
  default     = true
}

variable "enable_flow_logs" {
  description = "Enable VPC flow logs"
  type        = bool
  default     = true
}

variable "velero_backup_bucket" {
  description = "S3 bucket for Velero backups (scopes IAM permissions)"
  type        = string
  default     = ""
}

variable "route53_zone_arns" {
  description = "Route53 zone ARNs for cert-manager (scopes IAM permissions)"
  type        = list(string)
  default     = []
}

variable "tags" {
  description = "Additional tags for all resources"
  type        = map(string)
  default     = {}
}
`;
}

/**
 * Generate AWS EKS outputs.tf content
 */
export function generateAwsOutputsTf(): string {
  return `# AWS EKS Cluster - Outputs
# Auto-generated by monobase-infra provision wizard

output "cluster_id" {
  description = "EKS cluster ID"
  value       = module.eks_cluster.cluster_id
}

output "cluster_endpoint" {
  description = "EKS cluster API endpoint"
  value       = module.eks_cluster.cluster_endpoint
}

output "cluster_name" {
  description = "EKS cluster name"
  value       = module.eks_cluster.cluster_name
}

output "cluster_version" {
  description = "Kubernetes version"
  value       = module.eks_cluster.cluster_version
}

output "kubeconfig_command" {
  description = "Command to update kubeconfig"
  value       = "aws eks update-kubeconfig --region \${var.region} --name \${var.cluster_name}"
}

output "region" {
  description = "AWS region"
  value       = var.region
}

output "vpc_id" {
  description = "VPC ID"
  value       = module.eks_cluster.vpc_id
}

output "node_security_group_id" {
  description = "Security group ID for worker nodes"
  value       = module.eks_cluster.node_security_group_id
}

output "oidc_provider_arn" {
  description = "OIDC provider ARN for IRSA"
  value       = module.eks_cluster.oidc_provider_arn
}
`;
}

/**
 * Generate DigitalOcean DOKS main.tf content
 */
export function generateDoMainTf(): string {
  return `# DigitalOcean DOKS Cluster Configuration
# Auto-generated by monobase-infra provision wizard

terraform {
  required_version = ">= 1.6"

  required_providers {
    digitalocean = {
      source  = "digitalocean/digitalocean"
      version = "~> 2.0"
    }
  }
}

provider "digitalocean" {
  # Token from environment: DIGITALOCEAN_TOKEN or DIGITALOCEAN_ACCESS_TOKEN
}

module "doks_cluster" {
  source = "../terraform/modules/do-doks"

  cluster_name       = var.cluster_name
  region             = var.region
  kubernetes_version = var.kubernetes_version

  # Deployment size or custom node configuration
  deployment_profile = var.deployment_profile
  node_size          = var.node_size
  node_count         = var.node_count
  min_nodes          = var.min_nodes
  max_nodes          = var.max_nodes

  # High availability control plane
  ha_control_plane = var.ha_control_plane

  # Auto-upgrade settings
  auto_upgrade  = var.auto_upgrade
  surge_upgrade = var.surge_upgrade

  # Maintenance window
  maintenance_window_day  = var.maintenance_window_day
  maintenance_window_hour = var.maintenance_window_hour

  vpc_cidr = var.vpc_cidr
  tags     = var.tags
}
`;
}

/**
 * Generate k3d main.tf content
 */
export function generateK3dMainTf(): string {
  return `# k3d Local Development Cluster
# Auto-generated by monobase-infra provision wizard

terraform {
  required_version = ">= 1.0"
  required_providers {
    k3d = {
      source  = "pvotal-tech/k3d"
      version = "~> 0.0.7"
    }
  }
}

module "k3d_cluster" {
  source = "../terraform/modules/local-k3d"

  cluster_name        = var.cluster_name
  k3s_version         = var.k3s_version
  servers             = var.servers
  agents              = var.agents
  http_port           = var.http_port
  https_port          = var.https_port
  disable_traefik     = var.disable_traefik
  install_gateway_api = var.install_gateway_api
}
`;
}

/**
 * Generate k3d variables.tf content
 */
export function generateK3dVariablesTf(): string {
  return `# k3d Local Cluster - Variable Declarations
# Auto-generated by monobase-infra provision wizard

variable "cluster_name" {
  description = "Name of the k3d cluster"
  type        = string
  default     = "k3d-local"
}

variable "k3s_version" {
  description = "K3s version"
  type        = string
  default     = "v1.28.5-k3s1"
}

variable "servers" {
  description = "Number of server nodes (control plane)"
  type        = number
  default     = 1
}

variable "agents" {
  description = "Number of agent nodes (workers)"
  type        = number
  default     = 3
}

variable "http_port" {
  description = "HTTP port to expose (LoadBalancer)"
  type        = number
  default     = 80
}

variable "https_port" {
  description = "HTTPS port to expose (LoadBalancer)"
  type        = number
  default     = 443
}

variable "disable_traefik" {
  description = "Disable built-in Traefik (use Envoy Gateway instead)"
  type        = bool
  default     = true
}

variable "install_gateway_api" {
  description = "Install Gateway API CRDs"
  type        = bool
  default     = true
}
`;
}

/**
 * Generate k3d outputs.tf content
 */
export function generateK3dOutputsTf(): string {
  return `# k3d Local Cluster - Outputs
# Auto-generated by monobase-infra provision wizard

output "cluster_name" {
  description = "k3d cluster name"
  value       = module.k3d_cluster.cluster_name
}

output "kubeconfig_path" {
  description = "Path to kubeconfig file"
  value       = module.k3d_cluster.kubeconfig_path
}

output "api_endpoint" {
  description = "Kubernetes API endpoint"
  value       = module.k3d_cluster.api_endpoint
}
`;
}

/**
 * Generate k3d local terraform.tfvars content
 */
export function generateK3dTfvars(config: K3dConfig): string {
  return `# k3d Local Cluster Configuration
# Generated by monobase-infra provision wizard

cluster_name = "${config.clusterName}"
k3s_version  = "v1.28.5-k3s1"

# Cluster topology
servers = 1              # Control plane nodes
agents  = ${config.agents}              # Worker nodes

# Port mappings (host:container)
http_port  = 80
https_port = 443

# Disable Traefik (we use Envoy Gateway)
disable_traefik = true

# Install Gateway API CRDs
install_gateway_api = true
`;
}

/**
 * Generate terraform.tfvars for any provider
 */
export function generateTfvars(
  provider: string,
  config: AwsConfig | DoConfig | GcpConfig | K3dConfig
): string {
  switch (provider) {
    case 'aws-eks':
      return generateAwsTfvars(config as AwsConfig);
    case 'do-doks':
      return generateDoTfvars(config as DoConfig);
    case 'gcp-gke':
      return generateGcpTfvars(config as GcpConfig);
    case 'k3d':
      return generateK3dTfvars(config as K3dConfig);
    default:
      throw new Error(`Unknown provider: ${provider}`);
  }
}
